window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "weavely", "modulename": "weavely", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "weavely.blocks", "modulename": "weavely.blocks", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "weavely.blocks.BaseBlock", "modulename": "weavely.blocks", "qualname": "BaseBlock", "kind": "class", "doc": "<p>Base class for all blocks in the Weavely.</p>\n\n<p>Idea of the block is to have a simple way to contain any arbitrary data and operate on it in abstract way. The best\nanalogy for this is a simple paragraph in a text editor. It can contain any text, tables, images, etc. But you can\nmove the paragraph around, change its style, etc. without knowing what is inside it.</p>\n\n<p>Each of blocks must contain a <code>Data</code> object, which is a container for the arbitrary information that block can\noperate on. Specific data type must be defined in the inherited class.</p>\n\n<p>Each block has a name, which is used to reference the blocks in the application. It can be provided by the user on\nblock creation, or it will be generated automatically.</p>\n\n<h6 id=\"each-block-can-follow-one-of-two-ways-to-format-or-render-the-data\">Each block can follow one of two ways to format or render the data:</h6>\n\n<blockquote>\n  <p>a. It may specify a specific formatter or renderer object to use exclusively for this block.\n  b. Or, otherwise, it will use the default formatter or renderers provided by the downstream objects\n      implementation.</p>\n</blockquote>\n", "bases": "abc.ABC, typing.Generic[TData]"}, {"fullname": "weavely.blocks.BaseBlock.__init__", "modulename": "weavely.blocks", "qualname": "BaseBlock.__init__", "kind": "function", "doc": "<p>Initialize the block object.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>data (TData):</strong>  Data object containing any arbitrary data that block can operate on. Specific data type must\nbe defined in the inherited class.</li>\n<li><strong>name (str | None):</strong>  Optional name of the block. Used to reference the block in the file. If None, the block\nwill generate it based on the class name and some randomized suffix.</li>\n<li><strong>formatter (IBlockFormatter):</strong>  Formatter object to format the data object. If None, the block will\nuse the default formatter provided by the file formatter implementation.</li>\n<li><strong>renderer (IBlockRenderer | None):</strong>  Renderer object to render the block into a specific format.\nIf None, the block will use the default renderer provided by the file renderer implementation.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"s1\">&#39;TData&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">formatter</span><span class=\"p\">:</span> <span class=\"n\">weavely</span><span class=\"o\">.</span><span class=\"n\">formatters</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">IBlockFormatter</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">renderer</span><span class=\"p\">:</span> <span class=\"n\">weavely</span><span class=\"o\">.</span><span class=\"n\">renderers</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">IBlockRenderer</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "weavely.blocks.BaseBlock.data", "modulename": "weavely.blocks", "qualname": "BaseBlock.data", "kind": "variable", "doc": "<p>Get the data object contained in the block.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>TData: Data object.</p>\n</blockquote>\n", "annotation": ": &#x27;TData&#x27;"}, {"fullname": "weavely.blocks.BaseBlock.formatter", "modulename": "weavely.blocks", "qualname": "BaseBlock.formatter", "kind": "variable", "doc": "<p>Get the formatter object used by the block.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>IBlockFormatter | None: Formatter object.</p>\n</blockquote>\n", "annotation": ": weavely.formatters.base.IBlockFormatter | None"}, {"fullname": "weavely.blocks.BaseBlock.renderer", "modulename": "weavely.blocks", "qualname": "BaseBlock.renderer", "kind": "variable", "doc": "<p>Get the renderer object used by the block.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>IBlockRenderer | None: Renderer object.</p>\n</blockquote>\n", "annotation": ": weavely.renderers.base.IBlockRenderer | None"}, {"fullname": "weavely.blocks.BaseBlock.name", "modulename": "weavely.blocks", "qualname": "BaseBlock.name", "kind": "variable", "doc": "<p>Get the block name.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str: Block name.</p>\n</blockquote>\n", "annotation": ": str"}, {"fullname": "weavely.blocks.BaseBlock.by_data", "modulename": "weavely.blocks", "qualname": "BaseBlock.by_data", "kind": "function", "doc": "<p>Create a new block instance by providing the data object.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>name (str | None):</strong>  Optional name of the block. Used to reference the block in the file. If None, the block\nwill generate it based on the class name and some randomized suffix.</li>\n<li><strong>formatter (IBlockFormatter):</strong>  Formatter object to format the data object. If None, the block will\nuse the default formatter provided by the file formatter implementation.</li>\n<li><strong>renderer (IBlockRenderer | None):</strong>  Renderer object to render the block into a specific format.\nIf None, the block will use the default renderer provided by the file renderer implementation.</li>\n<li><strong>data (Any):</strong>  Arbitrary range of keyword arguments to initialize the data object.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Self: New block instance.</p>\n</blockquote>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>DataIsMissingError:</strong>  If information provided in <code>**data</code> is not enough to create data object.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">formatter</span><span class=\"p\">:</span> <span class=\"n\">weavely</span><span class=\"o\">.</span><span class=\"n\">formatters</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">IBlockFormatter</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">renderer</span><span class=\"p\">:</span> <span class=\"n\">weavely</span><span class=\"o\">.</span><span class=\"n\">renderers</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">IBlockRenderer</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Self</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavely.blocks.Data", "modulename": "weavely.blocks", "qualname": "Data", "kind": "class", "doc": "<p>Default label for data containing in the block to make operation on block more convenient.</p>\n\n<p>This class doesn't have any specific information, any specific Data type must be inherited from this class.</p>\n"}, {"fullname": "weavely.content", "modulename": "weavely.content", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "weavely.content.Content", "modulename": "weavely.content", "qualname": "Content", "kind": "class", "doc": "<p>A class to represent a file content.</p>\n\n<p>Responsible for storing, adding, removing and other operations with the file blocks.\nBy itself this class does not render the file content, as well as know nothing about blocks formatting, which\nis delegated to <code>File</code> object.</p>\n\n<p>Blocks are stored inside the contend as a dictionary, where the key is the block name, and the values is\nthe block object itself. This allows for simple block reference, as well as guarantees block insertion order.</p>\n"}, {"fullname": "weavely.content.Content.add_block", "modulename": "weavely.content", "qualname": "Content.add_block", "kind": "function", "doc": "<p>Add a new block to the content.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>block (BaseBlock[Data]):</strong>  Block object to add.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str: Name of the block.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">block</span><span class=\"p\">:</span> <span class=\"n\">weavely</span><span class=\"o\">.</span><span class=\"n\">blocks</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">BaseBlock</span><span class=\"p\">[</span><span class=\"n\">weavely</span><span class=\"o\">.</span><span class=\"n\">blocks</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">Data</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavely.content.Content.add_plain_text", "modulename": "weavely.content", "qualname": "Content.add_plain_text", "kind": "function", "doc": "<p>Add a new plain text block to the content.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>text (str):</strong>  Plain text that should be added to the content as a PlainText block.</li>\n<li><strong>name (str | None):</strong>  Name of the block. If not specified, it will be generated automatically.</li>\n<li><strong>formatter (IBlockFormatter | None):</strong>  Specific formatter to use for this block.</li>\n<li><strong>renderer (IBlockRenderer | None):</strong>  Specific renderer to use for this block.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str: Name of the block.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">formatter</span><span class=\"p\">:</span> <span class=\"n\">weavely</span><span class=\"o\">.</span><span class=\"n\">formatters</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">IBlockFormatter</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">renderer</span><span class=\"p\">:</span> <span class=\"n\">weavely</span><span class=\"o\">.</span><span class=\"n\">renderers</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">IBlockRenderer</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavely.errors", "modulename": "weavely.errors", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "weavely.errors.RendererIsUnknownError", "modulename": "weavely.errors", "qualname": "RendererIsUnknownError", "kind": "class", "doc": "<p>Raised in case any renderer is not found for a provided block item.</p>\n", "bases": "builtins.TypeError"}, {"fullname": "weavely.errors.DataIsMissingError", "modulename": "weavely.errors", "qualname": "DataIsMissingError", "kind": "class", "doc": "<p>Raised in case user do not specify enough information to create a data object for a block.</p>\n", "bases": "builtins.ValueError"}, {"fullname": "weavely.file", "modulename": "weavely.file", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "weavely.file.factory", "modulename": "weavely.file.factory", "kind": "module", "doc": "<p>Module contains factory functions for creating predefined SimpleFile objects for the most common use cases.</p>\n\n<p>You may use those items instead of populating everything on you own from scratch.</p>\n"}, {"fullname": "weavely.file.factory.get_empty_file", "modulename": "weavely.file.factory", "qualname": "get_empty_file", "kind": "function", "doc": "<p>Get an empty SimpleFile object.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>SimpleFile: Empty file object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">weavely</span><span class=\"o\">.</span><span class=\"n\">file</span><span class=\"o\">.</span><span class=\"n\">file</span><span class=\"o\">.</span><span class=\"n\">SimpleFile</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavely.file.factory.get_txt_file", "modulename": "weavely.file.factory", "qualname": "get_txt_file", "kind": "function", "doc": "<p>Get an SimpleFile object useful for writing of plain text files.</p>\n\n<p>It contains standard formatters and renderers for text data representation.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>SimpleFile: SimpleFile object with text data support.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">weavely</span><span class=\"o\">.</span><span class=\"n\">file</span><span class=\"o\">.</span><span class=\"n\">file</span><span class=\"o\">.</span><span class=\"n\">SimpleFile</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavely.file.file", "modulename": "weavely.file.file", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "weavely.file.file.SimpleFile", "modulename": "weavely.file.file", "qualname": "SimpleFile", "kind": "class", "doc": "<p>General representation of a file as an idea.</p>\n\n<p>Responsible for adding, modifying and removing data blocks from the file. As well, it orchestrates the document\nrendering process.</p>\n\n<p>Blocks are stored inside the file object as a dictionary where the key is the block name and the value is the\nblock object itself. This allows to simple block reference, as well as it guarantees block insertion order.</p>\n"}, {"fullname": "weavely.file.file.SimpleFile.__init__", "modulename": "weavely.file.file", "qualname": "SimpleFile.__init__", "kind": "function", "doc": "<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>formatter (FileFormatter):</strong>  Formatter object to format the file.</li>\n<li><strong>renderer (FileRenderer):</strong>  Renderer object to render the file.</li>\n<li><strong>encoding (str):</strong>  Encoding of the file content. Default is UTF-8.</li>\n<li><strong>delimiter (str):</strong>  Delimiter to separate blocks in the file content. Default is newline.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">formatter</span><span class=\"p\">:</span> <span class=\"n\">weavely</span><span class=\"o\">.</span><span class=\"n\">formatters</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">FileFormatter</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">renderer</span><span class=\"p\">:</span> <span class=\"n\">weavely</span><span class=\"o\">.</span><span class=\"n\">renderers</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">FileRenderer</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">encoding</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;utf-8&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">delimiter</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;</span><span class=\"se\">\\n</span><span class=\"s1\">&#39;</span></span>)</span>"}, {"fullname": "weavely.file.file.SimpleFile.set_renderer", "modulename": "weavely.file.file", "qualname": "SimpleFile.set_renderer", "kind": "function", "doc": "<p>Set the default renderer for the specified data type.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>data_type (type[Data]):</strong>  Data type to set the renderer for.</li>\n<li><strong>renderer (IBlockRenderer[Data]):</strong>  Renderer object to set.</li>\n<li><strong>replace (bool):</strong>  Flag to replace the existing renderer if it is already set. Default is False.</li>\n</ul>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>KeyError:</strong>  If the renderer is already set and the <code>replace</code> flag is not set.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">data_type</span><span class=\"p\">:</span> <span class=\"nb\">type</span><span class=\"p\">[</span><span class=\"n\">weavely</span><span class=\"o\">.</span><span class=\"n\">blocks</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">Data</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">renderer</span><span class=\"p\">:</span> <span class=\"n\">weavely</span><span class=\"o\">.</span><span class=\"n\">renderers</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">IBlockRenderer</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">replace</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavely.file.file.SimpleFile.set_formatter", "modulename": "weavely.file.file", "qualname": "SimpleFile.set_formatter", "kind": "function", "doc": "<p>Set the default formatter for the specified data type.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>data_type (type[Data]):</strong>  Data type to set the formatter for.</li>\n<li><strong>formatter (IBlockFormatter):</strong>  Formatter object to set.</li>\n<li><strong>replace (bool):</strong>  Flag to replace the existing formatter if it is already set. Default is False.</li>\n</ul>\n\n<h6 id=\"raises\">Raises:</h6>\n\n<ul>\n<li><strong>KeyError:</strong>  If the formatter is already set and the <code>replace</code> flag is not set.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">data_type</span><span class=\"p\">:</span> <span class=\"nb\">type</span><span class=\"p\">[</span><span class=\"n\">weavely</span><span class=\"o\">.</span><span class=\"n\">blocks</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">Data</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">formatter</span><span class=\"p\">:</span> <span class=\"n\">weavely</span><span class=\"o\">.</span><span class=\"n\">formatters</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">IBlockFormatter</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">replace</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavely.file.file.SimpleFile.get_renderer", "modulename": "weavely.file.file", "qualname": "SimpleFile.get_renderer", "kind": "function", "doc": "<p>Return the renderer object for the specified data type.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>data_type (type[Data]):</strong>  Data type to get the renderer for.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>IBlockRenderer | None: Renderer object for the specified data type.\n      If the renderer is not set, returns None.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">data_type</span><span class=\"p\">:</span> <span class=\"nb\">type</span><span class=\"p\">[</span><span class=\"n\">weavely</span><span class=\"o\">.</span><span class=\"n\">blocks</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">Data</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">weavely</span><span class=\"o\">.</span><span class=\"n\">renderers</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">IBlockRenderer</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavely.file.file.SimpleFile.get_formatter", "modulename": "weavely.file.file", "qualname": "SimpleFile.get_formatter", "kind": "function", "doc": "<p>Return the formatter object for the specified data type.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>data_type (type[Data]):</strong>  Data type to get the formatter for.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>IBlockFormatter | None: Formatter object for the specified data type.\n      If the formatter is not set, returns None.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">data_type</span><span class=\"p\">:</span> <span class=\"nb\">type</span><span class=\"p\">[</span><span class=\"n\">weavely</span><span class=\"o\">.</span><span class=\"n\">blocks</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">Data</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">weavely</span><span class=\"o\">.</span><span class=\"n\">formatters</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">IBlockFormatter</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavely.file.file.SimpleFile.remove_renderer", "modulename": "weavely.file.file", "qualname": "SimpleFile.remove_renderer", "kind": "function", "doc": "<p>Remove the default renderer for the specified data type.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>data_type (type[Data]):</strong>  Data type to remove the renderer for.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>IBlockRenderer | None: Removed renderer object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">data_type</span><span class=\"p\">:</span> <span class=\"nb\">type</span><span class=\"p\">[</span><span class=\"n\">weavely</span><span class=\"o\">.</span><span class=\"n\">blocks</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">Data</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">weavely</span><span class=\"o\">.</span><span class=\"n\">renderers</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">IBlockRenderer</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavely.file.file.SimpleFile.remove_formatter", "modulename": "weavely.file.file", "qualname": "SimpleFile.remove_formatter", "kind": "function", "doc": "<p>Remove the default formatter for the specified data type.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>data_type (type[Data]):</strong>  Data type to remove the formatter for.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>IBlockFormatter | None: Removed formatter object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">data_type</span><span class=\"p\">:</span> <span class=\"nb\">type</span><span class=\"p\">[</span><span class=\"n\">weavely</span><span class=\"o\">.</span><span class=\"n\">blocks</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">Data</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">weavely</span><span class=\"o\">.</span><span class=\"n\">formatters</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">IBlockFormatter</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavely.file.file.SimpleFile.encoding", "modulename": "weavely.file.file", "qualname": "SimpleFile.encoding", "kind": "variable", "doc": "<p>Get the encoding of the file content.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str: Encoding of the file content.</p>\n</blockquote>\n", "annotation": ": str"}, {"fullname": "weavely.file.file.SimpleFile.content", "modulename": "weavely.file.file", "qualname": "SimpleFile.content", "kind": "variable", "doc": "<p>Get the content of the file.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Content: File content object.</p>\n</blockquote>\n", "annotation": ": weavely.content.Content"}, {"fullname": "weavely.file.file.SimpleFile.as_str", "modulename": "weavely.file.file", "qualname": "SimpleFile.as_str", "kind": "function", "doc": "<p>Render the file content into a string representation.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str: String representation of the file content.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavely.file.file.SimpleFile.as_stream", "modulename": "weavely.file.file", "qualname": "SimpleFile.as_stream", "kind": "function", "doc": "<p>Render document content into a bytes stream.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>BytesIO: Bytes stream with the file content.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">_io</span><span class=\"o\">.</span><span class=\"n\">BytesIO</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavely.file.file.SimpleFile.to_file", "modulename": "weavely.file.file", "qualname": "SimpleFile.to_file", "kind": "function", "doc": "<p>Write document content to a provided file by the path.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Path: Path to the file with the rendered content.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">_local</span><span class=\"o\">.</span><span class=\"n\">Path</span> <span class=\"o\">|</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">_local</span><span class=\"o\">.</span><span class=\"n\">Path</span>:</span></span>", "funcdef": "def"}, {"fullname": "weavely.formatters", "modulename": "weavely.formatters", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "weavely.formatters.base", "modulename": "weavely.formatters.base", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "weavely.formatters.base.IBlockFormatter", "modulename": "weavely.formatters.base", "qualname": "IBlockFormatter", "kind": "class", "doc": "<p>Protocol for formatters used by the Weavely.</p>\n\n<p>Respecting the idea to have class-based formatters in general,\nthis protocol may be useful to define a common function-based formatter interface.</p>\n", "bases": "typing.Protocol"}, {"fullname": "weavely.formatters.base.IBlockFormatter.__init__", "modulename": "weavely.formatters.base", "qualname": "IBlockFormatter.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "weavely.formatters.base.BlockFormatterBase", "modulename": "weavely.formatters.base", "qualname": "BlockFormatterBase", "kind": "class", "doc": "<p>Base class for all formatters in the Weavely.</p>\n\n<p>Idea is to unify ways of data objects formatting behind the single interface and decouple it from the\nblock object itself.</p>\n\n<p>Each of formatters may implement the <code>__init__</code> method to accept any additional parameters required for the\nformatting process.</p>\n", "bases": "IBlockFormatter, abc.ABC, typing.Generic[TData]"}, {"fullname": "weavely.formatters.base.FileFormatter", "modulename": "weavely.formatters.base", "qualname": "FileFormatter", "kind": "class", "doc": "<p>Base class to describe a file formatter.</p>\n\n<p>It used as a container class for default block formatter objects used by File object.</p>\n\n<h6 id=\"selecting-of-the-formatter-for-specific-block-will-be-done-in-the-following-order\">Selecting of the formatter for specific block will be done in the following order:</h6>\n\n<blockquote>\n  <ol>\n  <li>If block has a specific formatter object, it will be used.</li>\n  <li>If it doesn't, file will try to find default formatter in corresponding file formatter instance.</li>\n  <li>If both are missing, the block will be kept as it is.</li>\n  </ol>\n</blockquote>\n", "bases": "collections.abc.MutableMapping[type[weavely.blocks.base.Data], weavely.formatters.base.IBlockFormatter]"}, {"fullname": "weavely.formatters.base.FileFormatter.__init__", "modulename": "weavely.formatters.base", "qualname": "FileFormatter.__init__", "kind": "function", "doc": "<p>Initialize the collection of default formatters.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>formatters (dict[type[Data], IBlockFormatter]):</strong>  Dictionary of default formatters</li>\n<li>to initialize the collection with.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">formatters</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">type</span><span class=\"p\">[</span><span class=\"n\">weavely</span><span class=\"o\">.</span><span class=\"n\">blocks</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">Data</span><span class=\"p\">],</span> <span class=\"n\">weavely</span><span class=\"o\">.</span><span class=\"n\">formatters</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">IBlockFormatter</span><span class=\"p\">]</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "weavely.formatters.base.FileFormatter.formatters", "modulename": "weavely.formatters.base", "qualname": "FileFormatter.formatters", "kind": "variable", "doc": "<p>Dictionary of default block formatters used by the <code>File</code> object.</p>\n\n<p>Key is a block data type, value is a block formatter object. It may be any object that implements the\n<code>IBlockFormatter</code> protocol. So it may be a callable class inheriting from the <code>BlockFormatterBase</code> class, or any\nfunction that repeat IBlockFormatter protocol.</p>\n", "annotation": ": dict[type[weavely.blocks.base.Data], weavely.formatters.base.IBlockFormatter]"}, {"fullname": "weavely.formatters.txt", "modulename": "weavely.formatters.txt", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "weavely.formatters.txt.TextWrapFormatter", "modulename": "weavely.formatters.txt", "qualname": "TextWrapFormatter", "kind": "class", "doc": "<p>Wrap the text data in the block to the specified width.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>*max_width (int):</strong>  Maximum width of the text data.</li>\n</ul>\n", "bases": "weavely.formatters.base.BlockFormatterBase[weavely.blocks.txt.PlainTextData]"}, {"fullname": "weavely.formatters.txt.TextWrapFormatter.__init__", "modulename": "weavely.formatters.txt", "qualname": "TextWrapFormatter.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">max_width</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">120</span></span>)</span>"}, {"fullname": "weavely.renderers", "modulename": "weavely.renderers", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "weavely.renderers.base", "modulename": "weavely.renderers.base", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "weavely.renderers.base.BlockRendererBase", "modulename": "weavely.renderers.base", "qualname": "BlockRendererBase", "kind": "class", "doc": "<p>Implementation of the <code>IBlockRenderer</code> protocol as a callable class.</p>\n\n<p>Responsible for rendering a block content into a string representation according to the specific document\nformat rules.</p>\n\n<p>Note the difference between formatters and renderers.</p>\n\n<p>Formatters are responsible for data formatting inside the block object, while block renderers are responsible for\ntransforming the block data info a representation suitable for the document format.</p>\n\n<p>NOTE: TData of the inherited renderer must repeat the <code>_SUPPORTED_DATA_TYPES</code> class attribute.</p>\n", "bases": "IBlockRenderer, abc.ABC, typing.Generic[TData]"}, {"fullname": "weavely.renderers.base.FileRenderer", "modulename": "weavely.renderers.base", "qualname": "FileRenderer", "kind": "class", "doc": "<p>Base class for a collection of default renderers used by the <code>File</code> object.</p>\n\n<p>When any block is rendered, it uses the following order to select the renderer:\n    1. If the block has a specific renderer, it will be used.\n    2. Otherwise, the default renderer will be used.\n    3. If no renderer is found, raises RendererIsUnknownError exception.</p>\n", "bases": "collections.abc.MutableMapping[type[weavely.blocks.base.Data], weavely.renderers.base.IBlockRenderer]"}, {"fullname": "weavely.renderers.base.FileRenderer.__init__", "modulename": "weavely.renderers.base", "qualname": "FileRenderer.__init__", "kind": "function", "doc": "<p>Initialize the collection of default renderers.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>renderers (dict[type[Data], IBlockRenderer]):</strong>  Dictionary of default renderers to initialize the collection\nwith.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">renderers</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">type</span><span class=\"p\">[</span><span class=\"n\">weavely</span><span class=\"o\">.</span><span class=\"n\">blocks</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">Data</span><span class=\"p\">],</span> <span class=\"n\">weavely</span><span class=\"o\">.</span><span class=\"n\">renderers</span><span class=\"o\">.</span><span class=\"n\">base</span><span class=\"o\">.</span><span class=\"n\">IBlockRenderer</span><span class=\"p\">]</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "weavely.renderers.base.IBlockRenderer", "modulename": "weavely.renderers.base", "qualname": "IBlockRenderer", "kind": "class", "doc": "<p>Protocol describing required interfaces of an object which may be registered as a block renderer.</p>\n\n<p>Responsible for rendering a block content into a string representation according to the specific document\nformat rules.</p>\n\n<p>Note the difference between <code>FormatterProtocol</code> and this protocol.</p>\n\n<p>Formatters are responsible for data formatting inside the block object, while block renderers are responsible for\ntransforming the block data info a representation suitable for the document format.</p>\n", "bases": "typing.Protocol"}, {"fullname": "weavely.renderers.base.IBlockRenderer.__init__", "modulename": "weavely.renderers.base", "qualname": "IBlockRenderer.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "weavely.renderers.txt", "modulename": "weavely.renderers.txt", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "weavely.renderers.txt.PlainTextRenderer", "modulename": "weavely.renderers.txt", "qualname": "PlainTextRenderer", "kind": "class", "doc": "<p>Renderer for the plain text block.</p>\n\n<p>Just returns the plain text in the same way it has been formatted.</p>\n", "bases": "weavely.renderers.base.BlockRendererBase[weavely.blocks.txt.PlainTextData]"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();